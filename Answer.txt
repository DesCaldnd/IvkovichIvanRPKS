Билет №20:
1.  Класс Object, его методы, правила переопределения методов, использование класса.
2. 	MongoDB – как устроена и для чего используется. Модель данных в MongoDB. Как производить поиск, вставку и удаления данных из MongoDB. Как в Java работать с MongoDB.
3.  Реализовать endpoint в TaskController, которому при запросе передаётся boostrapServers и название топика. В endpoint создаётся consumer Kafka, который читает топик, начиная с самых старых сообщений. Далее в Redis находим строку, по ключу первого сообщения из Kafka ("test") и возвращаем в endpoint значение из Redis в верхнем регистре и с обратным порядком букв

1)
В Java, класс Object является базовым (суперклассом) для всех классов. Любой другой класс в Java неявно наследуется от класса Object. Это означает, что каждый класс в Java является потомком Object.
Основные методы класса Object
Класс Object предоставляет несколько методов, которые доступны для всех объектов. Основные методы:
1. toString()
Этот метод возвращает строковое представление объекта.
По умолчанию реализация класса Object возвращает строку: имя класса + "@" + хэш код объекта в шестнадцатеричном виде

Переопределение:
Метод часто переопределяется для обеспечения более читабельного вывода. Например, в классе String он переопределен так, чтобы возвращать саму строку.

2. equals(Object obj)
Этот метод используется для проверки равенства двух объектов.
По умолчанию реализация в классе Object сравнивает ссылки (т.е. проверяет, указывают ли обе переменные на один и тот же объект в памяти).

Переопределение:
Для пользовательских классов часто переопределяется для содержательного сравнения объектов.

3. hashCode()
Возвращает хэш-код объекта, который используется, например, в коллекциях типа HashMap или HashSet.
По умолчанию метод возвращает целочисленный идентификатор, связанный с адресом объекта в памяти.
Правило переопределения: всегда нужно переопределять hashCode, если переопределяете equals, чтобы соблюсти контракт:
Если equals возвращает true для двух объектов, их hashCode также должен быть одинаковым.

4. clone()
Используется для создания копии объекта (поверхностное клонирование).
По умолчанию, метод вызывает CloneNotSupportedException, если класс не реализует интерфейс Cloneable.
Пример:
Этот метод следует использовать осторожно, так как поверхностное клонирование копирует только примитивные поля и ссылки, а не сами объекты, на которые указывают ссылки.

5. finalize()
Этот метод вызывается перед очисткой объекта.
Обычно он используется для освобождения ресурсов, но finalize считается устаревшим, и таким образом, он не рекомендуется к использованию.

6. getClass()
Возвращает объект типа Class, представляющий класс объекта во время выполнения.
Необходим для работы с Reflect API

7. wait(), notify(), notifyAll()
Эти методы используются для работы с синхронизацией внутри блоков synchronized.
wait(): Приостанавливает текущий поток до вызова notify/notifyAll другого потока.
notify(): Пробуждает один поток, ожидающий на том же мониторе.
notifyAll(): Пробуждает все потоки, ожидающие на том же мониторе.

Использование класса Object
Базовый класс для всех объектов:
Каждая переменная типа Object может ссылаться на объект любого класса
Полиморфизм:
Методы hashCode, equals и toString применяются во всех типах объектов благодаря тому, что они определены в классе Object.
Контейнеры и коллекции:
Объекты класса Object часто используются в стандартных коллекциях, таких как ArrayList<Object>, для хранения объектов различных типов.

2)
MongoDB — это NoSQL база данных, которая предназначена для хранения и управления данными в формате документов. 
В отличие от традиционных реляционных баз данных , MongoDB использует гибкую модель данных, основанную на документах, что делает её особенно удобной для работы с большими объемами данных и сложными структурами.

Основные характеристики MongoDB:
1.Документоориентированная архитектура:
Данные в MongoDB хранятся в виде документов, которые представлены в формате BSON.
Документы группируются в коллекции (аналог таблиц в реляционных БД).
2.Гибкая схема данных:
MongoDB не требует строгой предопределённой схемы данных, как в реляционных базах данных. Это означает, что документы в одной коллекции могут иметь разную структуру.
3.Масштабируемость:
MongoDB поддерживает горизонтальное масштабирование через механизм шардирования. Это позволяет распределить данные по нескольким серверам для обработки больших объемов данных.
Также поддерживается репликация для обеспечения отказоустойчивости и высокой доступности.
4.Производительность:
Благодаря индексации, кэшированию и оптимизации запросов, MongoDB демонстрирует высокую производительность даже при работе с большими объемами данных.
Поддержка агрегации данных позволяет выполнять сложные аналитические операции непосредственно в базе данных.
5.Поддержка геопространственных данных:
MongoDB имеет встроенные возможности для работы с географическими данными, такими как координаты и полигоны. Это полезно для приложений, связанных с картами и локациями.

Недостатки:
1.Высокое потребление памяти:
MongoDB может быть более ресурсоёмкой по сравнению с реляционными базами данных.
2.Ограниченная поддержка транзакций:
Хотя MongoDB поддерживает транзакции, они менее развиты, чем в реляционных БД.
3.Не всегда подходит для сложных JOIN-операций:
В MongoDB нет встроенной поддержки JOIN, как в SQL.


Документ — это основная единица данных в MongoDB.
Поддерживают вложенные объекты и массивы.
Гибкая структура: документы в одной коллекции могут иметь разную структуру.

Коллекция — это группа документов, аналог таблицы в реляционных базах данных.
В отличие от таблиц, коллекции не требуют строгой схемы данных.
Пример: коллекция users может содержать документы с разной структурой.
Коллекции могут содержать миллионы документов.

База данных — это контейнер, который группирует коллекции.
Каждая база данных имеет своё пространство имён и изолирована от других баз данных.
BSON — это формат сериализации данных, который расширяет JSON, добавляя поддержку дополнительных типов данных (например, даты, бинарные данные).

Поиск документов в коллекции db.collection.find()
Вставка одного документа db.collection.insertOne()
Вставка нескольких документов db.collection.insertMany()
Удаление одного документа db.collection.deleteOne()
Удаление нескольких документов db.collection.deleteMany()

Подключение
try (MongoClient mongoClient = MongoClients.create(connectionString)) {
    MongoDatabase database = mongoClient.getDatabase("mydatabase");

    MongoCollection<Document> collection = database.getCollection("mycollection");
} catch (Exception e) {
    e.printStackTrace();
}

Вставка

Document user1 = new Document("name", "Иван")
                    .append("age", 20)
                    .append("city", "Москва");
InsertOneResult result1 = collection.insertOne(user1);

List<Document> users = Arrays.asList(
    new Document("name", "Сергей").append("age", 35).append("city", "Екатеринбург"),
    new Document("name", "Иван").append("age", 22).append("city", "Новосибирск")
);
InsertManyResult result2 = collection.insertMany(users);

Поиск

FindIterable<Document> specificUsers = collection.find(
    Filters.or(
        Filters.eq("city", "Казань"),
        Filters.eq("city", "Новосибирск")
    )
);

Удаление

DeleteResult deleteOneResult = collection.deleteOne(Filters.eq("name", "Иван"));
DeleteResult deleteManyResult = collection.deleteMany(Filters.gt("age", 30));

Обновление

UpdateResult updateOneResult = collection.updateOne(
    Filters.eq("name", "Иван"),
    Updates.set("age", 29)
);

UpdateResult updateManyResult = collection.updateMany(
    Filters.eq("city", "Новосибирск"),
    Updates.inc("age", 1)
);

3) Сдано 8 лабораторных работ